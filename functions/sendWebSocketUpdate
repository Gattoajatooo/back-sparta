import { createClientFromRequest } from 'npm:@base44/sdk@0.7.1';

Deno.serve(async (req) => {
    try {
        const body = await req.json();
        
        console.log('[sendWebSocketUpdate] üì• Payload recebido:', JSON.stringify(body, null, 2));
        
        const wsBaseUrl = Deno.env.get('WEBSOCKET_ENDPOINT_URL');
        const wsToken = Deno.env.get('WEBSOCKET_AUTH_TOKEN');
        
        if (!wsBaseUrl || !wsToken) {
            console.log('WebSocket credentials not configured, skipping real-time update');
            return new Response(JSON.stringify({ 
                success: false, 
                error: 'WebSocket not configured' 
            }), {
                status: 500,
                headers: { 'Content-Type': 'application/json' }
            });
        }

        // üî• DETERMINAR company_id (pode estar em v√°rios lugares)
        const targetCompanyId = body.company_id || body.data?.company_id;
        
        if (!targetCompanyId) {
            console.log('WebSocket: company_id n√£o fornecido, pulando notifica√ß√£o');
            return new Response(JSON.stringify({ 
                success: false, 
                error: 'company_id is required' 
            }), {
                status: 400,
                headers: { 'Content-Type': 'application/json' }
            });
        }

        // üî• CONSTRUIR PAYLOAD FINAL
        // Se o body j√° tem campos estruturados (schedule_id, message_id, status), usa direto
        // Caso contr√°rio, usa a estrutura antiga com data
        let payload;
        
        if (body.schedule_id || body.message_id || body.status) {
            // ‚úÖ Payload j√° estruturado - usa como est√° (com campos no n√≠vel raiz)
            payload = {
                ...body,
                company_id: targetCompanyId,
                timestamp: new Date().toISOString()
            };
            console.log('[sendWebSocketUpdate] ‚úÖ Usando payload estruturado (campos no n√≠vel raiz)');
        } else {
            // ‚ùå Payload antigo - mant√©m compatibilidade
            const payloadData = body.data || body.sessionData || body.messageData || body.campaignData;
            payload = {
                type: body.type || body.eventType || 'update',
                company_id: targetCompanyId,
                data: payloadData,
                timestamp: new Date().toISOString()
            };
            console.log('[sendWebSocketUpdate] ‚ö†Ô∏è Usando payload legado (campos dentro de data)');
        }

        // Construir URL com company_id no path
        const wsEndpoint = `${wsBaseUrl}/realtime/${targetCompanyId}`;

        console.log(`[sendWebSocketUpdate] üì° Enviando para: ${wsEndpoint}`);
        console.log(`[sendWebSocketUpdate] üì¶ Payload final:`, JSON.stringify(payload, null, 2));

        const wsResponse = await fetch(wsEndpoint, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${wsToken}`
            },
            body: JSON.stringify(payload)
        });

        if (wsResponse.ok) {
            const result = await wsResponse.json();
            console.log(`[sendWebSocketUpdate] ‚úÖ Enviado com sucesso - ${result.delivered || 0} cliente(s) conectado(s)`);
            return new Response(JSON.stringify({ 
                success: true,
                delivered: result.delivered || 0
            }), {
                status: 200,
                headers: { 'Content-Type': 'application/json' }
            });
        } else {
            const errorText = await wsResponse.text();
            console.error(`[sendWebSocketUpdate] ‚ùå Erro: ${wsResponse.status} - ${errorText}`);
            return new Response(JSON.stringify({ 
                success: false, 
                error: `WebSocket error: ${wsResponse.status}` 
            }), {
                status: 500,
                headers: { 'Content-Type': 'application/json' }
            });
        }
    } catch (error) {
        console.error('[sendWebSocketUpdate] ‚ùå Erro ao enviar:', error);
        return new Response(JSON.stringify({ 
            success: false, 
            error: error.message 
        }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
        });
    }
});