import { createClientFromRequest } from 'npm:@base44/sdk@0.7.1';

Deno.serve(async (req) => {
    try {
        const base44 = createClientFromRequest(req);
        
        // ‚ö†Ô∏è Esta fun√ß√£o pode ser chamada por sistemas externos (webhooks WAHA, scheduler, etc)
        // Usa service role para maior flexibilidade
        
        const body = await req.json();
        const { session_name, ...updateData } = body;

        if (!session_name) {
            return Response.json({ 
                success: false, 
                error: 'session_name is required' 
            }, { status: 400 });
        }

        console.log(`[updateSession] Atualizando sess√£o ${session_name} com dados:`, updateData);

        // üî• Usar service role para buscar sess√£o
        const sessions = await base44.asServiceRole.entities.Session.filter({
            session_name: session_name
        });

        if (!sessions || sessions.length === 0) {
            return Response.json({ 
                success: false, 
                error: 'Session not found' 
            }, { status: 404 });
        }

        const session = sessions[0];
        
        // Preparar dados de atualiza√ß√£o
        const finalUpdateData = {
            ...updateData,
            last_activity: new Date().toISOString()
        };

        // üî• Atualizar com service role
        const updatedSession = await base44.asServiceRole.entities.Session.update(
            session.id, 
            finalUpdateData
        );

        console.log(`[updateSession] ‚úÖ Sess√£o ${session_name} atualizada com sucesso`);

        // üî• ENVIAR NOTIFICA√á√ÉO WEBSOCKET
        try {
            console.log(`[updateSession] üì° Enviando notifica√ß√£o WebSocket...`);
            
            // üî• Payload estruturado com campos no n√≠vel raiz
            const wsPayload = {
                type: 'session_updated',
                company_id: session.company_id,
                session_id: session.id,
                session_name: session_name,
                status: updateData.status || session.status,
                phone: updateData.phone || session.phone,
                avatar_url: updateData.avatar_url || session.avatar_url,
                data: {
                    ...updatedSession,
                    ...updateData
                }
            };

            const wsResponse = await base44.asServiceRole.functions.invoke('sendWebSocketUpdate', wsPayload);
            
            if (wsResponse?.data?.success) {
                console.log(`[updateSession] ‚úÖ WebSocket enviado - ${wsResponse.data.delivered || 0} cliente(s)`);
            } else {
                console.warn(`[updateSession] ‚ö†Ô∏è WebSocket falhou:`, wsResponse?.data);
            }
        } catch (wsError) {
            console.error(`[updateSession] ‚ùå Erro ao enviar WebSocket:`, wsError.message);
            // N√£o falhar a requisi√ß√£o se o WebSocket falhar
        }

        return Response.json({ 
            success: true,
            session_id: session.id,
            session_name: session_name,
            updated_data: finalUpdateData
        });

    } catch (error) {
        console.error('[updateSession] ‚ùå Erro:', error);
        return Response.json({ 
            success: false, 
            error: error.message 
        }, { status: 500 });
    }
});