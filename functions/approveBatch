import { createClientFromRequest } from 'npm:@base44/sdk@0.7.1';

// Helper para preencher vari√°veis
function fillVariables(content, contact, user, company) {
    if (!content) return '';
    let message = content;
    if (contact) {
        const firstName = contact.first_name || contact.name?.split(' ')[0] || '';
        const lastName = contact.last_name || contact.name?.split(' ').slice(1).join(' ') || '';
        const fullName = (contact.first_name && contact.last_name) 
            ? `${contact.first_name} ${contact.last_name}`.trim() 
            : contact.name || firstName;
        
        message = message.replace(/{{\s*first_name\s*}}/gi, firstName);
        message = message.replace(/{{\s*last_name\s*}}/gi, lastName);
        message = message.replace(/{{\s*full_name\s*}}/gi, fullName);
        message = message.replace(/{{\s*name\s*}}/gi, fullName);
        message = message.replace(/{{\s*email\s*}}/gi, contact.email || '');
        message = message.replace(/{{\s*phone\s*}}/gi, contact.phone || '');
        message = message.replace(/{{\s*company_name\s*}}/gi, contact.company_name || '');
    }
    if (user) {
        message = message.replace(/{{\s*user.full_name\s*}}/gi, user.full_name || '');
        message = message.replace(/{{\s*user.first_name\s*}}/gi, user.full_name?.split(' ')[0] || '');
        message = message.replace(/{{\s*user.email\s*}}/gi, user.email || '');
    }
    if (company) {
        message = message.replace(/{{\s*company.name\s*}}/gi, company.name || '');
    }
    return message;
}

Deno.serve(async (req) => {
    try {
        const base44 = createClientFromRequest(req);
        const user = await base44.auth.me();

        if (!user || !user.company_id) {
            return Response.json({ success: false, error: 'Unauthorized' }, { status: 401 });
        }

        const company = await base44.entities.Company.get(user.company_id);
        const { batch_id } = await req.json();

        if (!batch_id) {
            return Response.json({ success: false, error: 'batch_id is required' }, { status: 400 });
        }

        console.log('\nüéØ ========== APROVANDO LOTE ==========');
        console.log(`üì¶ Batch ID: ${batch_id}`);
        console.log(`üë§ User: ${user.email}`);

        // Buscar o lote
        const batch = await base44.asServiceRole.entities.BatchSchedule.get(batch_id);

        if (!batch) {
            return Response.json({ success: false, error: 'Batch not found' }, { status: 404 });
        }

        if (batch.status !== 'pending') {
            return Response.json({ 
                success: false, 
                error: `Batch cannot be approved. Current status: ${batch.status}` 
            }, { status: 400 });
        }

        console.log(`   Status atual: ${batch.status}`);
        console.log(`   Din√¢mico: ${batch.is_dynamic ? 'Sim' : 'N√£o'}`);

        // Se for din√¢mico, recalcular contatos
        let finalRecipients = batch.recipients || [];

        if (batch.is_dynamic) {
            console.log('\nüîÑ Recalculando contatos para campanha din√¢mica...');
            
            if (!batch.contact_filters || batch.contact_filters.length === 0) {
                return Response.json({ 
                    success: false, 
                    error: 'Dynamic batch has no contact filters defined' 
                }, { status: 400 });
            }

            // Chamar fun√ß√£o de filtros din√¢micos
            const { getFilteredContactsByRules } = await import('./getFilteredContactsByRules.js');
            const filteredResult = await getFilteredContactsByRules({
                filters: batch.contact_filters,
                logic: batch.filter_logic || 'AND'
            });

            if (!filteredResult.data?.success) {
                return Response.json({ 
                    success: false, 
                    error: 'Failed to calculate dynamic contacts',
                    details: filteredResult.data?.error 
                }, { status: 500 });
            }

            const dynamicContacts = filteredResult.data.contacts || [];
            console.log(`   ‚úì ${dynamicContacts.length} contatos encontrados pelos filtros`);

            // Converter para formato de recipients
            finalRecipients = dynamicContacts.map(contact => ({
                contact_id: contact.id,
                name: `${contact.first_name || ''} ${contact.last_name || ''}`.trim(),
                phone: contact.phone,
                email: contact.email
            }));

            // Atualizar o lote com os novos recipients
            await base44.asServiceRole.entities.BatchSchedule.update(batch_id, {
                recipients: finalRecipients,
                recipient_count: finalRecipients.length
            });

            console.log(`   ‚úì Lote atualizado com ${finalRecipients.length} destinat√°rios`);
        } else {
            console.log(`   ‚ÑπÔ∏è  Usando ${finalRecipients.length} destinat√°rios est√°ticos`);
        }

        if (finalRecipients.length === 0) {
            return Response.json({ 
                success: false, 
                error: 'No recipients found for this batch' 
            }, { status: 400 });
        }

        // Buscar templates
        const templates = [];
        if (batch.template_ids && batch.template_ids.length > 0) {
            console.log(`\nüìù Carregando ${batch.template_ids.length} template(s)...`);
            const templatePromises = batch.template_ids.map(id => 
                base44.asServiceRole.entities.MessageTemplate.get(id).catch(() => null)
            );
            const results = await Promise.all(templatePromises);
            templates.push(...results.filter(Boolean));
            console.log(`   ‚úì ${templates.length} template(s) carregado(s)`);
        }

        if (templates.length === 0) {
            return Response.json({ success: false, error: 'No valid templates found' }, { status: 400 });
        }

        // Buscar schedule pai
        const parentSchedule = await base44.asServiceRole.entities.Schedule.get(batch.schedule_id);

        // Buscar contatos completos
        const contactIds = finalRecipients.map(r => r.contact_id).filter(Boolean);
        const fullContacts = {};
        if (contactIds.length > 0) {
            console.log(`\nüë• Carregando ${contactIds.length} contato(s) completo(s)...`);
            const contactPromises = contactIds.map(id => 
                base44.asServiceRole.entities.Contact.get(id).catch(() => null)
            );
            const results = await Promise.all(contactPromises);
            results.filter(Boolean).forEach(contact => fullContacts[contact.id] = contact);
            console.log(`   ‚úì ${Object.keys(fullContacts).length} contato(s) carregado(s)`);
        }

        // Preparar payloads para o Cloudflare Scheduler
        console.log('\nüì¶ Preparando mensagens para agendamento no Cloudflare...');
        const allSchedulerPayloads = [];
        let currentTime = batch.run_at;

        const { interval_random_min = 20000, interval_random_max = 60000 } = batch.delivery_settings || {};

        for (const [index, recipient] of finalRecipients.entries()) {
            const contactData = fullContacts[recipient.contact_id] || recipient;
            const template = templates[index % templates.length];
            
            const templateContentType = template.content_type || 'text';

            if (index > 0) {
                const interval = Math.floor(Math.random() * (interval_random_max - interval_random_min + 1)) + interval_random_min;
                currentTime += interval;
            }

            const sessionName = batch.selected_sessions[index % batch.selected_sessions.length];
            const formattedPhone = String(contactData.phone).replace(/\D/g, '');
            const chatId = `${formattedPhone}@c.us`;

            const basePayload = {
                batch_id: batch_id,
                company_id: user.company_id,
                contact_id: recipient.contact_id,
                user_id: user.id,
                schedule_id: batch.schedule_id,
                session_name: sessionName,
                chat_id: chatId,
                direction: 'sent',
                type: 'scheduled',
                run_at: currentTime,
                created_at: Date.now(),
                updated_at: Date.now(),
                metadata: {
                    campaign_name: parentSchedule.name,
                    template_id: template.id,
                    template_name: template.name,
                    schedule_id: batch.schedule_id,
                    batch_id: batch_id,
                    recipient_name: contactData.first_name
                }
            };

            let schedulerMessagePayload;
            
            if (templateContentType === 'text') {
                const finalContent = fillVariables(template.content, contactData, user, company);
                schedulerMessagePayload = {
                    ...basePayload,
                    content: finalContent,
                    message_type: 'text'
                };
            } else {
                const attachment = template.attachments?.[0];
                
                if (!attachment || !attachment.url) {
                    console.warn(`Template ${template.id} tem content_type ${templateContentType} mas n√£o tem anexo v√°lido. Pulando...`);
                    continue;
                }

                const caption = template.content ? fillVariables(template.content, contactData, user, company) : '';

                let workerMessageType = templateContentType;
                if (templateContentType === 'audio') {
                    workerMessageType = 'voice';
                }

                schedulerMessagePayload = {
                    ...basePayload,
                    content: caption,
                    message_type: workerMessageType,
                    caption: caption,
                    filename: attachment.filename,
                    mimetype: attachment.mimetype || attachment.type,
                    file_url: attachment.url,
                    metadata: {
                        ...basePayload.metadata,
                        attachment: {
                            url: attachment.url,
                            filename: attachment.filename,
                            mimetype: attachment.mimetype || attachment.type,
                            type: templateContentType
                        }
                    }
                };
            }

            allSchedulerPayloads.push(schedulerMessagePayload);
        }

        console.log(`   ‚úì ${allSchedulerPayloads.length} mensagem(ns) preparada(s) para o Cloudflare`);

        // Enviar para Cloudflare e depois criar no banco
        console.log('\n‚òÅÔ∏è  Enviando jobs para Cloudflare...');
        
        const BATCH_SIZE_CLOUDFLARE = 100;
        const messagesToCreate = [];
        
        const scheduleUrl = Deno.env.get("SCHEDULE_URL");
        const jobsApiKey = Deno.env.get("JOBS_API_KEY");

        for (let i = 0; i < allSchedulerPayloads.length; i += BATCH_SIZE_CLOUDFLARE) {
            const chunk = allSchedulerPayloads.slice(i, i + BATCH_SIZE_CLOUDFLARE);
            const chunkNumber = Math.floor(i / BATCH_SIZE_CLOUDFLARE) + 1;
            const totalChunks = Math.ceil(allSchedulerPayloads.length / BATCH_SIZE_CLOUDFLARE);
            
            console.log(`   üì§ Chunk ${chunkNumber}/${totalChunks} (${chunk.length} mensagens)...`);

            try {
                const schedulerResponse = await fetch(`${scheduleUrl}/jobs/batch`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json', 
                        'Authorization': `Bearer ${jobsApiKey}` 
                    },
                    body: JSON.stringify(chunk)
                });

                if (!schedulerResponse.ok) {
                    const errorText = await schedulerResponse.text();
                    throw new Error(`Erro do scheduler (${schedulerResponse.status}): ${errorText}`);
                }
                
                const schedulerResult = await schedulerResponse.json();

                if (schedulerResult.success && Array.isArray(schedulerResult.data)) {
                    let successCount = 0;
                    let failCount = 0;
                    
                    schedulerResult.data.forEach((jobResult, index) => {
                        const originalPayload = chunk[index];
                        
                        if (jobResult.ok && jobResult.job?.id) {
                            messagesToCreate.push({
                                ...originalPayload,
                                scheduler_job_id: jobResult.job.id,
                                status: 'pending'
                            });
                            successCount++;
                        } else {
                            messagesToCreate.push({
                                ...originalPayload,
                                scheduler_job_id: null,
                                status: 'failed',
                                error_details: `Falha no Cloudflare: ${jobResult.error || 'Erro desconhecido'}`
                            });
                            failCount++;
                        }
                    });
                    
                    console.log(`   ‚úì Chunk ${chunkNumber}: ${successCount} agendados, ${failCount} falharam`);
                } else {
                    throw new Error(`Resposta inv√°lida do scheduler`);
                }
            } catch (error) {
                console.error(`   ‚ùå Erro no chunk ${chunkNumber}:`, error.message);
                
                chunk.forEach(payload => {
                    messagesToCreate.push({
                        ...payload,
                        scheduler_job_id: null,
                        status: 'failed',
                        error_details: `Erro ao enviar para Cloudflare: ${error.message}`
                    });
                });
            }
            
            if (i + BATCH_SIZE_CLOUDFLARE < allSchedulerPayloads.length) {
                await new Promise(resolve => setTimeout(resolve, 300));
            }
        }

        const totalScheduled = messagesToCreate.filter(m => m.status === 'pending').length;
        const totalFailed = messagesToCreate.filter(m => m.status === 'failed').length;
        
        console.log(`\n   üìä Resumo Cloudflare: ${totalScheduled} agendadas, ${totalFailed} falharam`);

        // Criar mensagens no Base44
        console.log('\nüíæ Salvando mensagens no Base44...');
        
        const BATCH_SIZE_BASE44 = 200;
        let totalCreated = 0;

        for (let i = 0; i < messagesToCreate.length; i += BATCH_SIZE_BASE44) {
            const chunkBase44 = messagesToCreate.slice(i, i + BATCH_SIZE_BASE44);
            const chunkNumber = Math.floor(i / BATCH_SIZE_BASE44) + 1;
            const totalChunks = Math.ceil(messagesToCreate.length / BATCH_SIZE_BASE44);
            
            console.log(`   üíæ Chunk ${chunkNumber}/${totalChunks} (${chunkBase44.length} mensagens)...`);
            
            try {
                await base44.asServiceRole.entities.Message.bulkCreate(chunkBase44);
                totalCreated += chunkBase44.length;
                console.log(`   ‚úì Chunk ${chunkNumber} salvo`);
            } catch (error) {
                console.error(`   ‚ùå Erro chunk ${chunkNumber}:`, error.message);
            }
            
            if (i + BATCH_SIZE_BASE44 < messagesToCreate.length) {
                await new Promise(resolve => setTimeout(resolve, 300));
            }
        }

        // Atualizar status do lote
        await base44.asServiceRole.entities.BatchSchedule.update(batch_id, {
            status: 'approved',
            approved_by: user.id,
            approved_at: new Date().toISOString()
        });

        console.log(`\n‚úÖ Lote aprovado! ${totalScheduled} agendadas, ${totalCreated} criadas no Base44\n`);

        return Response.json({
            success: true,
            batch_id: batch_id,
            messages_created: totalCreated,
            messages_scheduled: totalScheduled,
            messages_failed: totalFailed,
            recipients_count: finalRecipients.length,
            message: 'Batch approved and messages scheduled successfully'
        });

    } catch (error) {
        console.error('\n‚ùå Erro ao aprovar lote:', error);
        return Response.json({
            success: false,
            error: 'Internal server error',
            details: error.message
        }, { status: 500 });
    }
});